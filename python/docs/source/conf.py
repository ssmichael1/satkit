# Jupyter Notebook documentation build configuration file, created by
# sphinx-quickstart on Mon Apr 13 09:51:11 2015.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.
import os
import shutil
import sys
import pathlib
import ast
import re
import satkit as sk

sys.path.insert(0, "python/satkit")
sys.path.insert(0, "../satkit")

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.doctest",
    "sphinx.ext.intersphinx",
    "sphinx.ext.napoleon",
    "sphinx.ext.mathjax",
    "IPython.sphinxext.ipython_console_highlighting",
    "nbsphinx",
    "myst_parser",
]


myst_enable_extensions = ["html_image", "amsmath", "dollarmath"]
myst_update_mathjax = False

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]


# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
source_suffix = {".md": "markdown"}

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "SatKit"
copyright = "2026 Steven Michael"
author = "Steven Michael (ssmichael@gmail.com)"

# ghissue config
github_project_url = "https://github.com/ssmichael1/satkit"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#

cwd = pathlib.Path(__file__).parent.resolve()

# _version_py = os.path.join(cwd, "../../satkit/_version.py")
# version_ns = {}
# exec(
#    compile(open(_version_py).read(), _version_py, "exec"), version_ns
# )  # noqa: S102, SIM115
# The short X.Y version.
# version = "%i.%i" % version_ns["version_info"][:2]
# version = version_ns["__version__"]
# The full version, including alpha/beta/rc tags.
# release = version_ns["__version__"]
version = sk.version
release = sk.version


# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = "en"


# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = [
    "_build/**",
    "html/**",
    "examples/Notebook/.ipynb_checkpoints",
    "examples/Notebook/nbpackage/*.ipynb",
    "examples/Notebook/nbpackage/nbs/*.ipynb",
]

# The reST default role (used for this markup: `text`) to use for all
# documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = "sphinx"

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
# keep_warnings = False

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# html_theme = "alabaster"
html_theme = "sphinx_rtd_theme"

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = "examples/images/jupyter_logo.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# NOTE: Sphinx's 'make html' builder will throw a warning about an unfound
#       _static directory. Do not remove or comment out html_static_path
#       since it is needed to properly generate _static in the build directory
html_static_path = ["_static"]


def _rewrite_google_sections(lines: list[str]) -> list[str]:
    out: list[str] = []
    i = 0

    arg_re = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*)\s*(?:\(([^)]*)\))?\s*:\s*(.*)$")
    typed_re = re.compile(r"^([^:]+?)\s*:\s*(.*)$")

    while i < len(lines):
        line = lines[i]
        header = line.strip()
        if header not in {"Args:", "Arguments:", "Returns:", "Raises:"}:
            out.append(line)
            i += 1
            continue

        out.append(header)
        out.append("")
        i += 1

        current_item_lines: list[str] | None = None

        while i < len(lines):
            raw = lines[i]
            stripped = raw.strip()

            if not stripped:
                i += 1
                continue

            if not raw.startswith("    "):
                break

            m = arg_re.match(stripped) if header in {"Args:", "Arguments:"} else typed_re.match(stripped)
            if m:
                if current_item_lines is not None:
                    out.extend(current_item_lines)

                if header in {"Args:", "Arguments:"}:
                    arg_name, arg_type, arg_desc = m.group(1), m.group(2), m.group(3)
                    if arg_type:
                        current_item_lines = [
                            f"- ``{arg_name} ({arg_type})``",
                            f"  {arg_desc}",
                        ]
                    else:
                        current_item_lines = [
                            f"- ``{arg_name}``",
                            f"  {arg_desc}",
                        ]
                else:
                    ret_type, ret_desc = m.group(1).strip(), m.group(2).strip()
                    current_item_lines = [
                        f"- ``{ret_type}``",
                        f"  {ret_desc}",
                    ]
            elif current_item_lines is not None:
                if len(current_item_lines) >= 2:
                    current_item_lines[1] = f"{current_item_lines[1]} {stripped}"
                else:
                    current_item_lines[-1] = f"{current_item_lines[-1]} {stripped}"
            else:
                out.append(stripped)

            i += 1

        if current_item_lines is not None:
            out.extend(current_item_lines)

        out.append("")

    return out


def _normalize_doc_lines(lines: list[str]) -> list[str]:
    lines = _rewrite_google_sections(lines)
    normalized: list[str] = []
    for line in lines:
        is_bullet = line.lstrip().startswith("* ")
        is_dash_bullet = line.lstrip().startswith("- ")
        prev_is_bullet = bool(normalized) and normalized[-1].lstrip().startswith("* ")
        prev_is_dash_bullet = bool(normalized) and normalized[-1].lstrip().startswith("- ")

        if is_bullet and normalized and normalized[-1].strip():
            normalized.append("")
        if is_dash_bullet and normalized and normalized[-1].strip():
            normalized.append("")
        if not is_bullet and prev_is_bullet and line.strip():
            normalized.append("")
        if not is_dash_bullet and prev_is_dash_bullet and line.strip():
            normalized.append("")

        normalized.append(line)

    return normalized


def _module_names_for_stub(stub_path: pathlib.Path) -> list[str]:
    if stub_path.name == "satkit.pyi":
        return ["satkit", "satkit.satkit"]
    if stub_path.name == "__init__.pyi":
        return ["satkit"]
    return [f"satkit.{stub_path.stem}"]


def _collect_stub_docstrings() -> dict[str, list[str]]:
    stub_docs: dict[str, list[str]] = {}
    stub_dir = cwd.parent.parent / "satkit"

    for stub_path in stub_dir.glob("*.pyi"):
        module_names = _module_names_for_stub(stub_path)

        try:
            tree = ast.parse(stub_path.read_text(encoding="utf-8"))
        except Exception:
            continue

        module_doc = ast.get_docstring(tree, clean=True)
        if module_doc:
            doc_lines = _normalize_doc_lines(module_doc.splitlines())
            for module_name in module_names:
                stub_docs[module_name] = doc_lines

        for node in tree.body:
            if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
                obj_doc = ast.get_docstring(node, clean=True)
                if obj_doc:
                    doc_lines = _normalize_doc_lines(obj_doc.splitlines())
                    for module_name in module_names:
                        stub_docs[f"{module_name}.{node.name}"] = doc_lines

                if isinstance(node, ast.ClassDef):
                    for child in node.body:
                        if isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef)):
                            child_doc = ast.get_docstring(child, clean=True)
                            if child_doc:
                                doc_lines = _normalize_doc_lines(child_doc.splitlines())
                                for module_name in module_names:
                                    stub_docs[f"{module_name}.{node.name}.{child.name}"] = (
                                        doc_lines
                                    )

    return stub_docs


_STUB_DOCS = _collect_stub_docstrings()


def _inject_stub_docstring(_app, _what, name, _obj, _options, lines):
    if name in {"satkit.satstate.propagate", "satkit.satkit.satstate.propagate"}:
        lines[:] = [
            "Propagates the satellite state to a target time or duration.",
        ]
        return

    if name in {"satkit.sgp4", "satkit.satkit.sgp4"}:
        lines[:] = [
            "Runs SGP4 propagation for one or more TLE/OMM inputs at one or more times.",
        ]
        return

    doc_lines = _STUB_DOCS.get(name)

    if doc_lines is None and name.startswith("satkit.satkit."):
        doc_lines = _STUB_DOCS.get(f"satkit.{name.removeprefix('satkit.satkit.')}")
    if doc_lines is None and name.startswith("satkit."):
        doc_lines = _STUB_DOCS.get(f"satkit.satkit.{name.removeprefix('satkit.')}")

    if doc_lines is not None:
        lines[:] = doc_lines


def setup(app):
    app.add_css_file("theme_mods.css")
    app.connect("autodoc-process-docstring", _inject_stub_docstring, priority=100)


# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
# html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Language to be used for generating the HTML full-text search index.
# Sphinx supports the following languages:
#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
# html_search_language = 'en'

# A dictionary with options for the search language support, empty by default.
# Now only 'ja' uses this config value
# html_search_options = {'type': 'default'}

# The name of a javascript file (relative to the configuration directory) that
# implements a search results scorer. If empty, the default will be used.
# html_search_scorer = 'scorer.js'

# Output file base name for HTML help builder.
htmlhelp_basename = "JupyterNotebookdoc"

# This will ensure that we use the correctly set environment for canonical URLs
# Old Read the Docs injections makes it point only to the default version,
# for instance /en/stable/
html_baseurl = os.environ.get("READTHEDOCS_CANONICAL_URL", "/")

# -- Options for LaTeX output ---------------------------------------------

latex_elements = {}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        master_doc,
        "JupyterNotebook.tex",
        "Jupyter Notebook Documentation",
        "https://jupyter.org",
        "manual",
    ),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, "jupyternotebook", "Jupyter Notebook Documentation", [author], 1)
]

# If true, show URL addresses after external links.
# man_show_urls = False


# -- Options for link checks ----------------------------------------------

linkcheck_ignore = [r"http://127\.0\.0\.1/*"]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        master_doc,
        "JupyterNotebook",
        "Jupyter Notebook Documentation",
        author,
        "JupyterNotebook",
        "One line description of project.",
        "Miscellaneous",
    ),
]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
# texinfo_no_detailmenu = False

intersphinx_mapping = {
    "ipython": ("https://ipython.readthedocs.io/en/stable/", None),
    "nbconvert": ("https://nbconvert.readthedocs.io/en/latest/", None),
    "nbformat": ("https://nbformat.readthedocs.io/en/latest/", None),
    "jupyter": ("https://jupyter.readthedocs.io/en/latest/", None),
}

spelling_lang = "en_US"
spelling_word_list_filename = "spelling_wordlist.txt"

# primary_domain = "python"
highlight_language = "python"
